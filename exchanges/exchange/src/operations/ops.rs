use std::collections::{HashMap, HashSet};
use std::convert::{TryFrom, TryInto};

use anyhow::{anyhow, Error, Result};
use async_trait::async_trait;
use chrono::{DateTime, TimeZone, Utc};
use serde::Deserialize;
use tokio::sync::{mpsc, RwLock};
use tracing::{debug, span, Level};

use crate::operations::{db, storage::Storage};
use market::{self, Asset, Market, MarketData};

use crate::{
    ExchangeDataFetcher, Loan, Repay, Trade, TradeSide, Withdraw,
};

#[derive(Clone, Debug, Deserialize)]
pub enum OperationStatus {
    Success,
    Failed,
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct AssetBalance {
    pub amount: f64,
    pub usd_position: f64,
}

/// Types of operations used to express any type of
/// transaction.
#[derive(Debug, Clone, PartialEq)]
pub enum Operation {
    BalanceIncrease {
        id: u8,
        source_id: String,
        source: String,
        asset: String,
        amount: f64,
    },
    BalanceDecrease {
        id: u8,
        source_id: String,
        source: String,
        asset: String,
        amount: f64,
    },
    // Cost of acquiring an asset
    Cost {
        id: u8,
        source_id: String,
        source: String,
        // for which asset the cost was incurred
        for_asset: String,
        for_amount: f64,
        asset: String,
        amount: f64,
        time: DateTime<Utc>,
    },
    // Revenue generated by selling an asset
    Revenue {
        id: u8,
        source_id: String,
        source: String,
        asset: String,
        amount: f64,
        time: DateTime<Utc>,
    },
}

impl Operation {
    fn id(&self) -> String {
        match self {
            Self::BalanceIncrease { id, source_id, .. } => {
                format!("balance_increase-{}-{}", source_id, id)
            }
            Self::BalanceDecrease { id, source_id, .. } => {
                format!("balance_decrease-{}-{}", source_id, id,)
            }
            Self::Cost { id, source_id, .. } => format!("cost-{}-{}", source_id, id),
            Self::Revenue { id, source_id, .. } => format!("revenue-{}-{}", source_id, id),
        }
    }

    pub fn time(&self) -> Option<&DateTime<Utc>> {
        use Operation::*;
        match self {
            Cost { time, .. } => Some(time),
            Revenue { time, .. } => Some(time),
            _ => None,
        }
    }

    pub fn amount(&self) -> f64 {
        use Operation::*;
        match self {
            Cost { amount, .. } => *amount,
            Revenue { amount, .. } => *amount,
            BalanceIncrease { amount, .. } => *amount,
            BalanceDecrease { amount, .. } => *amount,
        }
    }
}

impl TryFrom<db::Operation> for Operation {
    type Error = Error;

    fn try_from(op: db::Operation) -> Result<Operation> {
        match op.op_type.as_str() {
            "cost" => Ok(Operation::Cost {
                id: op.op_id,
                source_id: op.source_id,
                source: op.source,
                for_asset: op
                    .for_asset
                    .ok_or_else(|| anyhow!("missing for_asset in cost operation"))?,
                for_amount: op
                    .for_amount
                    .ok_or_else(|| anyhow!("missing for_amount in cost operation"))?,
                asset: op.asset,
                amount: op.amount,
                time: Utc.timestamp(
                    op.timestamp
                        .ok_or_else(|| anyhow!("missing timestamp in cost operation"))?,
                    0,
                ),
            }),
            "revenue" => Ok(Operation::Revenue {
                id: op.op_id,
                source_id: op.source_id,
                source: op.source,
                asset: op.asset,
                amount: op.amount,
                time: Utc.timestamp(
                    op.timestamp
                        .ok_or_else(|| anyhow!("missing timestamp in revenue operation"))?,
                    0,
                ),
            }),
            "balance_increase" => Ok(Operation::BalanceIncrease {
                id: op.op_id,
                source_id: op.source_id,
                source: op.source,
                asset: op.asset,
                amount: op.amount,
            }),
            "balance_decrease" => Ok(Operation::BalanceDecrease {
                id: op.op_id,
                source_id: op.source_id,
                source: op.source,
                asset: op.asset,
                amount: op.amount,
            }),
            _ => Err(anyhow!("couldn't convert db operation into operation")),
        }
    }
}

pub struct BalanceTracker<T> {
    coin_balances: RwLock<HashMap<String, AssetBalance>>,
    operations_seen: RwLock<HashSet<String>>,
    batch: RwLock<Vec<Operation>>,
    market_data: T,
}

impl<T: MarketData> BalanceTracker<T> {
    pub fn new(asset_info: T) -> Self {
        BalanceTracker {
            coin_balances: RwLock::new(HashMap::new()),
            operations_seen: RwLock::new(HashSet::new()),
            batch: RwLock::new(Vec::new()),
            market_data: asset_info,
        }
    }

    async fn track_operation(
        &self,
        op: &Operation,
        balance: &mut HashMap<String, AssetBalance>,
    ) -> Result<()> {
        match op {
            Operation::BalanceIncrease { asset, amount, .. } => {
                let span = span!(Level::DEBUG, "tracking balance increase");
                let _enter = span.enter();
                debug!("start");
                assert!(
                    *amount >= 0.0,
                    "balance increase operation amount can't be negative"
                );
                let coin_balance = balance.entry(asset.clone()).or_default();
                coin_balance.amount += amount;
                debug!("end");
            }
            Operation::BalanceDecrease { asset, amount, .. } => {
                let span = span!(Level::DEBUG, "tracking balance decrease");
                let _enter = span.enter();
                debug!("start");
                assert!(
                    *amount >= 0.0,
                    "balance decrease operation amount can't be negative"
                );
                let coin_balance = balance.entry(asset.clone()).or_default();
                coin_balance.amount -= amount;
                debug!("end");
            }
            Operation::Cost {
                for_asset,
                asset,
                amount,
                time,
                ..
            } => {
                let span = span!(Level::DEBUG, "tracking cost");
                let _enter = span.enter();
                debug!("start");
                let usd_market = Market::new(asset, "USD");
                let usd_price =
                    market::solve_price(&self.market_data, &usd_market, &time)
                        .await?.ok_or_else(|| anyhow!("couldn't find price for {:?}", usd_market))?;
                let coin_balance = balance.entry(for_asset.clone()).or_default();
                coin_balance.usd_position += -amount * usd_price;
                debug!("end")
            }
            Operation::Revenue {
                asset,
                amount,
                time,
                ..
            } => {
                let span = span!(Level::DEBUG, "tracking revenue");
                let _enter = span.enter();
                debug!("start");
                let usd_market = Market::new(asset, "USD");
                let usd_price =
                    market::solve_price(&self.market_data, &usd_market, &time)
                        .await?.ok_or_else(|| anyhow!("couldn't find price for {:?}", usd_market))?;
                let coin_balance = balance.entry(asset.clone()).or_default();
                coin_balance.usd_position += amount * usd_price;
                debug!("end");
            }
        }
        Ok(())
    }

    pub async fn process_batch(&self) -> Result<()> {
        let mut bal = self.coin_balances.write().await;
        for op in self.batch.read().await.iter() {
            self.track_operation(op, &mut *bal).await?;
        }
        self.batch.write().await.clear();
        Ok(())
    }

    pub async fn batch_operation(&self, op: Operation) {
        if self.operations_seen.read().await.contains(&op.id()) {
            log::info!("ignoring duplicate operation {:?}", op);
            return;
        }
        self.operations_seen.write().await.insert(op.id());
        self.batch.write().await.push(op);
    }

    pub async fn get_balance(&self, asset: &str) -> Option<AssetBalance> {
        self.coin_balances
            .read()
            .await
            .get(asset)
            .clone()
            .map(|v| v.clone())
    }

    pub async fn balances(&self) -> Vec<(String, AssetBalance)> {
        self.coin_balances
            .read()
            .await
            .clone()
            .into_iter()
            .collect()
    }
}

/// Construct to create pipelines that process operations.
/// Receives and processes operations, then passes them through
/// to the next processor through the `sender` channel. The last processor
/// won't be provided with a sender channel.
#[async_trait]
pub trait OperationsProcesor {
    async fn process(
        &self,
        mut receiver: mpsc::Receiver<Operation>,
        sender: Option<mpsc::Sender<Operation>>,
    ) -> Result<()>;
}

const OPS_RECEIVE_BATCH_SIZE: usize = 1000;

/// Flushes batched operations into the db
pub struct OperationsFlusher<S> {
    ops_storage: S,
}

impl<S: Storage> OperationsFlusher<S> {
    pub fn new(ops_storage: S) -> Self {
        Self { ops_storage }
    }
    async fn flush(&self, batch: Vec<Operation>) -> Result<usize> {
        let mut seen_ops = HashSet::new();
        let (inserted, skipped) = self
            .ops_storage
            .insert_ops(
                batch
                    .into_iter()
                    .inspect(|op| {
                        if seen_ops.contains(&op.id()) {
                            log::info!("duplicate op {} {:?}", op.id(), op);
                        } else {
                            seen_ops.insert(op.id());
                        }
                    })
                    .filter_map(|op| op.try_into().map_or(None, |op| Some(op)))
                    .collect(),
            )
            .await?;
        log::debug!(
            "flushed {} operations into db, skipped = {}",
            inserted,
            skipped
        );
        Ok(inserted)
    }
}

#[async_trait]
impl<S: Storage + Send + Sync> OperationsProcesor for OperationsFlusher<S> {
    async fn process(
        &self,
        mut receiver: mpsc::Receiver<Operation>,
        sender: Option<mpsc::Sender<Operation>>,
    ) -> Result<()> {
        log::info!("syncing operations to db...");
        let mut batch = Vec::with_capacity(OPS_RECEIVE_BATCH_SIZE);
        let mut num_ops = 0;
        let mut num_fetched = 0;
        while let Some(op) = receiver.recv().await {
            batch.push(op.clone());
            if batch.len() == OPS_RECEIVE_BATCH_SIZE {
                log::info!("batched {}", OPS_RECEIVE_BATCH_SIZE);
                num_ops += self.flush(batch).await?;
                num_fetched += OPS_RECEIVE_BATCH_SIZE;
                batch = Vec::with_capacity(OPS_RECEIVE_BATCH_SIZE);
            }
            if let Some(sender) = sender.as_ref() {
                sender.send(op).await?;
            }
        }
        log::debug!("channel for receiving ops closed in operations flusher");
        if batch.len() > 0 {
            log::info!("batched {}", batch.len());
            num_fetched += batch.len();
            num_ops += self.flush(batch).await?;
        };
        log::info!("fetched={} inserted={}", num_fetched, num_ops);
        Ok(())
    }
}

/// Fetches prices for assets and stores on the db based on the processed
/// operations.
pub struct PricesFetcher<T> {
    asset_prices: AssetPrices<T>,
}

impl<T> PricesFetcher<T> {
    pub fn new(asset_prices: AssetPrices<T>) -> Self {
        Self { asset_prices }
    }
}

#[async_trait]
impl<T: MarketData + Send + Sync> OperationsProcesor for PricesFetcher<T> {
    async fn process(
        &self,
        mut receiver: mpsc::Receiver<Operation>,
        sender: Option<mpsc::Sender<Operation>>,
    ) -> Result<()> {
        log::info!("syncing asset prices to db...");
        while let Some(op) = receiver.recv().await {
            log::debug!("processing op {:?}", op);
            // the `.usd_price_at(..)` call will make the DB to populate with
            // bucket of prices corresponding to each processed transaction.
            match &op {
                Operation::Cost { asset, time, .. } | Operation::Revenue { asset, time, .. } => {
                    self.asset_prices.usd_price_at(asset, time).await?;
                }
                _ => (),
            }
            if let Some(sender) = sender.as_ref() {
                sender.send(op).await?;
            }
        }
        debug!("channel for receiving ops closed in prices fetcher");
        Ok(())
    }
}

/// stores buckets to prices in the db, buckets are periods of time
/// defined by number of days of span.
pub struct AssetPrices<T> {
    market_data: T,
}

impl<T: MarketData> AssetPrices<T> {
    pub fn new(market_data: T) -> Self {
        Self { market_data }
    }

    /// Fetch the price of the asset in USD at the provided datetime, it'll try to fetch it
    /// from different markets.
    async fn usd_price_at(&self, asset: &Asset, datetime: &DateTime<Utc>) -> Result<f64> {
        log::debug!("fetching usd price for {}", asset);
        if asset.to_lowercase() == "usd" {
            return Ok(1.0);
        }

        let usd_market = Market::new(asset.to_ascii_lowercase(), "usd");
        market::solve_price(&self.market_data, &usd_market, &datetime).await?
            .ok_or_else(|| anyhow!("couldn't find price for {:?}", usd_market))
    }
}

async fn ops_from_fetcher<'a>(
    prefix: &'a str,
    c: Box<dyn ExchangeDataFetcher + Send + Sync>,
) -> Result<Vec<Operation>> {
    let mut all_ops: Vec<Operation> = Vec::new();
    log::info!("[{}] fetching trades...", prefix);
    all_ops.extend(
        c.trades()
            .await?
            .into_iter()
            .flat_map(|t| -> Vec<Operation> { t.into() }),
    );
    log::info!("[{}] fetching margin trades...", prefix);
    all_ops.extend(
        c.margin_trades()
            .await?
            .into_iter()
            .flat_map(|t| -> Vec<Operation> { t.into() }),
    );
    log::info!("[{}] fetching loans...", prefix);
    all_ops.extend(
        c.loans()
            .await?
            .into_iter()
            .flat_map(|t| -> Vec<Operation> { t.into() }),
    );
    log::info!("[{}] fetching repays...", prefix);
    all_ops.extend(
        c.repays()
            .await?
            .into_iter()
            .flat_map(|t| -> Vec<Operation> { t.into() }),
    );
    log::info!("[{}] fetching deposits...", prefix);
    all_ops.extend(
        c.deposits()
            .await?
            .into_iter()
            .flat_map(|t| -> Vec<Operation> { t.into() }),
    );
    log::info!("[{}] fetching withdraws...", prefix);
    all_ops.extend(
        c.withdraws()
            .await?
            .into_iter()
            .flat_map(|t| -> Vec<Operation> { t.into() }),
    );
    log::info!("[{}] ALL DONE!!!", prefix);
    Ok(all_ops)
}

pub async fn fetch_ops<'a>(
    fetchers: Vec<(&'static str, Box<dyn ExchangeDataFetcher + Send + Sync>)>,
) -> mpsc::Receiver<Operation> {
    let (tx, rx) = mpsc::channel(100_000);

    for (name, f) in fetchers.into_iter() {
        let txc = tx.clone();
        tokio::spawn(async move {
            match ops_from_fetcher(name, f).await {
                Ok(ops) => {
                    for op in ops {
                        match txc.send(op).await {
                            Ok(()) => (),
                            Err(err) => log::error!("could not send operation: {}", err),
                        }
                    }
                    log::debug!("finished sending ops for fetcher {}", name);
                }
                Err(err) => log::error!("failed to fetch operations from {}: {}", name, err),
            };
        });
    }

    rx
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{Status, Deposit};
    use quickcheck::{quickcheck, Arbitrary, Gen, TestResult};
    use tokio::sync::Mutex;
    use Operation::*;

    impl Arbitrary for OperationStatus {
        fn arbitrary(g: &mut Gen) -> Self {
            g.choose(&[Self::Success, Self::Failed]).cloned().unwrap()
        }
    }

    impl Arbitrary for Operation {
        fn arbitrary(g: &mut Gen) -> Self {
            let assets: &[&str] = &["BTC", "ETH", "SOL", "AVAX", "USD"];
            let source_id = u8::arbitrary(g).to_string();
            let source = g
                .choose(&["binance", "FTX", "other-source"])
                .unwrap()
                .to_string();
            // non-zero amounts
            let for_amount: f64 = 0.1 + u16::arbitrary(g) as f64;
            let amount: f64 = 0.1 + u16::arbitrary(g) as f64;
            let for_asset = g.choose(&assets).unwrap().to_string();
            let asset = g.choose(&assets).unwrap().to_string();

            match g.choose(&[0, 1, 2, 3]).unwrap() {
                &0 => Operation::Cost {
                    id: u8::arbitrary(g),
                    source_id,
                    source,
                    for_asset,
                    for_amount,
                    asset,
                    amount,
                    time: Utc::now(),
                },
                &1 => Operation::Revenue {
                    id: u8::arbitrary(g),
                    source_id,
                    source,
                    asset,
                    amount,
                    time: Utc::now(),
                },
                &2 => Operation::BalanceIncrease {
                    id: u8::arbitrary(g),
                    source_id,
                    source,
                    asset,
                    amount,
                },
                &3 => Operation::BalanceDecrease {
                    id: u8::arbitrary(g),
                    source_id,
                    source,
                    asset,
                    amount,
                },
                _ => panic!("unexpected index"),
            }
        }
    }

    #[test]
    fn trade_buy_into_operations() {
        fn prop(trade: Trade) -> TestResult {
            if matches!(trade.side, TradeSide::Sell) {
                return TestResult::discard();
            }

            let t = trade.clone();
            let ops: Vec<Operation> = trade.into();

            let num_ops = if t.fee > 0.0 { 6 } else { 4 };
            if ops.len() != num_ops {
                println!(
                    "incorrect number of ops expected {} got {}",
                    num_ops,
                    ops.len()
                );
                return TestResult::failed();
            }

            match &ops[0] {
                BalanceIncrease { asset, amount, .. } => {
                    if asset != &t.base_asset || amount != &t.amount {
                        println!("non-matching fields for op 1");
                        return TestResult::failed();
                    }
                }
                _ => {
                    println!("not matching op 1 type");
                    return TestResult::failed();
                }
            }

            match &ops[1] {
                Cost {
                    for_asset,
                    for_amount,
                    asset,
                    amount,
                    ..
                } => {
                    if for_asset != &t.base_asset
                        || for_amount != &t.amount
                        || asset != &t.quote_asset
                        || amount != &(t.price * t.amount)
                    {
                        println!("non-matching fields for op 2");
                        return TestResult::failed();
                    }
                }
                _ => {
                    println!("not matching op 2 type");
                    return TestResult::failed();
                }
            }

            match &ops[2] {
                BalanceDecrease { asset, amount, .. } => {
                    if asset != &t.quote_asset || amount != &(t.amount * t.price) {
                        println!("non-matching fields for op 3");
                        return TestResult::failed();
                    }
                }
                _ => {
                    println!("not matching op 3 type");
                    return TestResult::failed();
                }
            }

            match &ops[3] {
                Revenue { asset, amount, .. } => {
                    if asset != &t.quote_asset || amount != &(t.amount * t.price) {
                        println!("non-matching fields for op 4");
                        return TestResult::failed();
                    }
                }
                _ => {
                    println!("not matching op 4 type");
                    return TestResult::failed();
                }
            }

            if t.fee > 0.0 {
                match &ops[4] {
                    BalanceDecrease { asset, amount, .. } => {
                        if asset != &t.fee_asset || amount != &t.fee {
                            println!("non-matching fields for op 5");
                            return TestResult::failed();
                        }
                    }
                    _ => {
                        println!("not matching op 5 type");
                        return TestResult::failed();
                    }
                }
                match &ops[5] {
                    Cost {
                        for_asset,
                        for_amount,
                        asset,
                        amount,
                        ..
                    } => {
                        if for_asset != &t.base_asset
                            || for_amount != &0.0
                            || asset != &t.fee_asset
                            || amount != &t.fee
                        {
                            println!("non-matching fields for op 6");
                            return TestResult::failed();
                        }
                    }
                    _ => {
                        println!("not matching op 6 type");
                        return TestResult::failed();
                    }
                }
            }

            return TestResult::passed();
        }
        quickcheck(prop as fn(Trade) -> TestResult);
    }

    #[test]
    fn trade_sell_into_operations() {
        fn prop(trade: Trade) -> TestResult {
            if matches!(trade.side, TradeSide::Buy) {
                return TestResult::discard();
            }

            let t = trade.clone();
            let ops: Vec<Operation> = trade.into();

            let num_ops = if t.fee > 0.0 { 6 } else { 4 };
            if ops.len() != num_ops {
                println!(
                    "incorrect number of ops expected {} got {}",
                    num_ops,
                    ops.len()
                );
                return TestResult::failed();
            }

            match &ops[0] {
                BalanceDecrease { asset, amount, .. } => {
                    if asset != &t.base_asset || amount != &t.amount {
                        println!("non-matching fields for op 1");
                        return TestResult::failed();
                    }
                }
                _ => {
                    println!("not matching op 1 type");
                    return TestResult::failed();
                }
            }

            match &ops[1] {
                Revenue { asset, amount, .. } => {
                    if asset != &t.base_asset || amount != &t.amount {
                        println!("non-matching fields for op 2");
                        return TestResult::failed();
                    }
                }
                _ => {
                    println!("not matching op 2 type");
                    return TestResult::failed();
                }
            }

            match &ops[2] {
                BalanceIncrease { asset, amount, .. } => {
                    if asset != &t.quote_asset || amount != &(t.amount * t.price) {
                        println!("non-matching fields for op 3");
                        return TestResult::failed();
                    }
                }
                _ => {
                    println!("not matching op 3 type");
                    return TestResult::failed();
                }
            }

            match &ops[3] {
                Cost {
                    for_asset,
                    for_amount,
                    asset,
                    amount,
                    ..
                } => {
                    if for_asset != &t.quote_asset
                        || for_amount != &(t.amount * t.price)
                        || asset != &t.base_asset
                        || amount != &t.amount
                    {
                        println!("non-matching fields for op 4");
                        return TestResult::failed();
                    }
                }
                _ => {
                    println!("not matching op 4 type");
                    return TestResult::failed();
                }
            }

            if t.fee > 0.0 {
                match &ops[4] {
                    BalanceDecrease { asset, amount, .. } => {
                        if asset != &t.fee_asset && amount != &t.fee {
                            println!("non-matching fields for op 5");
                            return TestResult::failed();
                        }
                    }
                    _ => {
                        println!("not matching op 5 type");
                        return TestResult::failed();
                    }
                }
                match &ops[5] {
                    Cost {
                        for_asset,
                        for_amount,
                        asset,
                        amount,
                        ..
                    } => {
                        if for_asset != &t.quote_asset
                            || for_amount != &0.0
                            || asset != &t.fee_asset
                            || amount != &t.fee
                        {
                            println!("non-matching fields for op 6");
                            return TestResult::failed();
                        }
                    }
                    _ => {
                        println!("not matching op 6 type");
                        return TestResult::failed();
                    }
                }
            }

            return TestResult::passed();
        }
        quickcheck(prop as fn(Trade) -> TestResult);
    }

    #[test]
    fn deposit_into_operations() {
        fn prop(deposit: Deposit) -> TestResult {
            if deposit.amount == 0.0 {
                return TestResult::discard();
            }

            let d = deposit.clone();
            let ops: Vec<Operation> = deposit.into();

            let num_ops = if let Some(_) = d.fee.filter(|f| f > &0.0) {
                3
            } else {
                1
            };
            if ops.len() != num_ops {
                println!(
                    "incorrect number of ops expected {} got {}",
                    num_ops,
                    ops.len()
                );
                return TestResult::failed();
            }

            match &ops[0] {
                BalanceIncrease { asset, amount, .. } => {
                    if asset != &d.asset || amount != &d.amount {
                        println!("non-matching fields for op 1");
                        return TestResult::failed();
                    }
                }
                _ => {
                    println!("not matching op 1 type");
                    return TestResult::failed();
                }
            }

            if let Some(fee) = d.fee.filter(|f| f > &0.0) {
                match &ops[1] {
                    BalanceDecrease { asset, amount, .. } => {
                        if asset != &d.asset && amount != &fee {
                            println!("non-matching fields for op 2");
                            return TestResult::failed();
                        }
                    }
                    _ => {
                        println!("not matching op 2 type");
                        return TestResult::failed();
                    }
                }
                match &ops[2] {
                    Cost {
                        for_asset,
                        for_amount,
                        asset,
                        amount,
                        ..
                    } => {
                        if for_asset != &d.asset
                            || for_amount != &0.0
                            || asset != &d.asset
                            || amount != &fee
                        {
                            println!("non-matching fields for op 6");
                            return TestResult::failed();
                        }
                    }
                    _ => {
                        println!("not matching op 6 type");
                        return TestResult::failed();
                    }
                }
            }

            return TestResult::passed();
        }
        quickcheck(prop as fn(Deposit) -> TestResult);
    }

    #[test]
    fn withdraw_into_operations() {
        fn prop(withdraw: Withdraw) -> TestResult {
            if withdraw.amount == 0.0 {
                return TestResult::discard();
            }

            let d = withdraw.clone();
            let ops: Vec<Operation> = withdraw.into();

            let num_ops = if d.fee > 0.0 { 3 } else { 1 };
            if ops.len() != num_ops {
                println!(
                    "incorrect number of ops expected {} got {}",
                    num_ops,
                    ops.len()
                );
                return TestResult::failed();
            }

            match &ops[0] {
                BalanceDecrease { asset, amount, .. } => {
                    if asset != &d.asset || amount != &d.amount {
                        println!("non-matching fields for op 1");
                        return TestResult::failed();
                    }
                }
                _ => {
                    println!("not matching op 1 type");
                    return TestResult::failed();
                }
            }

            if d.fee > 0.0 {
                match &ops[1] {
                    BalanceDecrease { asset, amount, .. } => {
                        if asset != &d.asset && amount != &d.fee {
                            println!("non-matching fields for op 2");
                            return TestResult::failed();
                        }
                    }
                    _ => {
                        println!("not matching op 2 type");
                        return TestResult::failed();
                    }
                }
                match &ops[2] {
                    Cost {
                        for_asset,
                        for_amount,
                        asset,
                        amount,
                        ..
                    } => {
                        if for_asset != &d.asset
                            || for_amount != &0.0
                            || asset != &d.asset
                            || amount != &d.fee
                        {
                            println!("non-matching fields for op 6");
                            return TestResult::failed();
                        }
                    }
                    _ => {
                        println!("not matching op 6 type");
                        return TestResult::failed();
                    }
                }
            }

            return TestResult::passed();
        }
        quickcheck(prop as fn(Withdraw) -> TestResult);
    }

    #[test]
    fn loan_into_operations() {
        fn prop(loan: Loan) -> TestResult {
            if loan.amount == 0.0 {
                return TestResult::discard();
            }

            let d = loan.clone();
            let ops: Vec<Operation> = loan.into();

            let num_ops = match d.status {
                Status::Success => 1,
                Status::Failure => 0,
            };
            if ops.len() != num_ops {
                println!(
                    "incorrect number of ops expected {} got {}",
                    num_ops,
                    ops.len()
                );
                return TestResult::failed();
            }

            if num_ops > 0 {
                match &ops[0] {
                    BalanceIncrease { asset, amount, .. } => {
                        if asset != &d.asset || amount != &d.amount {
                            println!("non-matching fields for op 1");
                            return TestResult::failed();
                        }
                    }
                    _ => {
                        println!("not matching op 1 type");
                        return TestResult::failed();
                    }
                }
            }
            return TestResult::passed();
        }
        quickcheck(prop as fn(Loan) -> TestResult);
    }

    #[test]
    fn repay_into_operations() {
        fn prop(repay: Repay) -> TestResult {
            if repay.amount == 0.0 {
                return TestResult::discard();
            }

            let d = repay.clone();
            let ops: Vec<Operation> = repay.into();

            let num_ops = match d.status {
                Status::Success => 2,
                Status::Failure => 0,
            };
            if ops.len() != num_ops {
                println!(
                    "incorrect number of ops expected {} got {}",
                    num_ops,
                    ops.len()
                );
                return TestResult::failed();
            }

            if num_ops > 0 {
                match &ops[0] {
                    BalanceDecrease { asset, amount, .. } => {
                        if asset != &d.asset || amount != &(d.amount + d.interest) {
                            println!("non-matching fields for op 1");
                            return TestResult::failed();
                        }
                    }
                    _ => {
                        println!("not matching op 1 type");
                        return TestResult::failed();
                    }
                }
                match &ops[1] {
                    Cost {
                        for_asset,
                        for_amount,
                        asset,
                        amount,
                        ..
                    } => {
                        if for_asset != &d.asset
                            || for_amount != &0.0
                            || asset != &d.asset
                            || amount != &d.interest
                        {
                            println!("non-matching fields for op 2");
                            return TestResult::failed();
                        }
                    }
                    _ => {
                        println!("not matching op 2 type");
                        return TestResult::failed();
                    }
                }
            }
            return TestResult::passed();
        }
        quickcheck(prop as fn(Repay) -> TestResult);
    }

    #[tokio::test]
    async fn track_operations() -> Result<()> {
        struct TestMarketData {
            prices: Mutex<Vec<f64>>,
        }

        impl TestMarketData {
            fn new() -> Self {
                Self {
                    prices: Mutex::new(vec![7000.0, 25.0, 95.0]),
                }
            }
        }

        #[async_trait]
        impl MarketData for TestMarketData {
            async fn has_market(&self, market: &Market) -> Result<bool> {
                Ok(true)
            }

            async fn markets(&self) -> Result<Vec<Market>> {
                Ok(vec![])
            }

            async fn price_at(&self, market: &Market, _time: &DateTime<Utc>) -> Result<f64> {
                Ok(match (market.base.as_str(), market.quote.as_str()) {
                    ("USDT" | "USD", "USDT" | "USD") => 1.0,
                    _ => self.prices.lock().await.remove(0),
                })
            }
        }

        let coin_tracker = BalanceTracker::new(TestMarketData::new());
        let ops = vec![
            Operation::BalanceIncrease {
                id: 1,
                source_id: "1".to_string(),
                source: "test".to_string(),
                asset: "BTC".into(),
                amount: 0.03,
            },
            Operation::Cost {
                id: 2,
                source_id: "2".to_string(),
                source: "test".to_string(),
                for_asset: "BTC".to_string(),
                for_amount: 0.03,
                asset: "USD".into(),
                amount: 255.0,
                time: Utc::now(),
            },
            Operation::BalanceIncrease {
                id: 3,
                source_id: "3".to_string(),
                source: "test".to_string(),
                asset: "BTC".into(),
                amount: 0.1,
            },
            Operation::Cost {
                id: 4,
                source_id: "4".to_string(),
                source: "test".to_string(),
                for_asset: "BTC".into(),
                for_amount: 0.1,
                asset: "USD".into(),
                amount: 890.0,
                time: Utc::now(),
            },
            Operation::BalanceIncrease {
                id: 5,
                source_id: "5".to_string(),
                source: "test".to_string(),
                asset: "ETH".into(),
                amount: 0.5,
            },
            Operation::Cost {
                id: 6,
                source_id: "6".to_string(),
                source: "test".to_string(),
                for_asset: "ETH".into(),
                for_amount: 0.5,
                asset: "USD".into(),
                amount: 1000.0,
                time: Utc::now(),
            },
            Operation::BalanceIncrease {
                id: 7,
                source_id: "7".to_string(),
                source: "test".to_string(),
                asset: "ETH".into(),
                amount: 0.01,
            },
            Operation::Cost {
                id: 8,
                source_id: "1".to_string(),
                source: "test".to_string(),
                for_asset: "ETH".into(),
                for_amount: 0.01,
                asset: "USD".into(),
                amount: 21.0,
                time: Utc::now(),
            },
            Operation::BalanceDecrease {
                id: 9,
                source_id: "9".to_string(),
                source: "test".to_string(),
                asset: "ETH".into(),
                amount: 0.2,
            },
            Operation::Revenue {
                id: 10,
                source_id: "10".to_string(),
                source: "test".to_string(),
                asset: "ETH".into(),
                amount: 0.2,
                time: Utc::now(),
            },
            Operation::BalanceIncrease {
                id: 11,
                source_id: "11".to_string(),
                source: "test".to_string(),
                asset: "DOT".into(),
                amount: 0.5,
            },
            Operation::Cost {
                id: 12,
                source_id: "12".to_string(),
                source: "test".to_string(),
                for_asset: "DOT".into(),
                for_amount: 0.5,
                asset: "USD".into(),
                amount: 7.5,
                time: Utc::now(),
            },
            Operation::BalanceDecrease {
                id: 13,
                source_id: "13".to_string(),
                source: "test".to_string(),
                asset: "DOT".into(),
                amount: 0.1,
            },
            Operation::Revenue {
                id: 14,
                source_id: "14".to_string(),
                source: "test".to_string(),
                asset: "DOT".into(),
                amount: 0.1,
                time: Utc::now(),
            },
            Operation::BalanceDecrease {
                id: 15,
                source_id: "15".to_string(),
                source: "test".to_string(),
                asset: "DOT".into(),
                amount: 0.2,
            },
            Operation::Revenue {
                id: 16,
                source_id: "16".to_string(),
                source: "test".to_string(),
                asset: "DOT".into(),
                amount: 0.2,
                time: Utc::now(),
            },
        ];

        for op in ops {
            coin_tracker.batch_operation(op).await;
        }
        coin_tracker.process_batch().await?;

        let mut expected = vec![
            (
                "BTC".to_string(),
                AssetBalance {
                    amount: 0.13,
                    usd_position: -1145.0,
                },
            ),
            (
                "ETH".to_string(),
                AssetBalance {
                    amount: 0.31,
                    usd_position: 379.0,
                },
            ),
            (
                "DOT".to_string(),
                AssetBalance {
                    amount: 0.2,
                    usd_position: 14.0,
                },
            ),
        ];

        expected.sort_by_key(|x| x.0.clone());

        let mut balances = coin_tracker.balances().await;
        balances.sort_by_key(|x| x.0.clone());

        for ((asset_a, balance_a), (asset_b, balance_b)) in expected.iter().zip(balances.iter()) {
            assert_eq!(asset_a, asset_b);
            println!("{}", asset_a);
            assert_eq!(balance_a, balance_b);
        }

        Ok(())
    }
}
